# 🎯 前端核心技能水平测试题库

## 📊 测试说明

### 评分标准
- **Level 1 (1-2分)**：基础了解，需要查资料
- **Level 2 (3-4分)**：基本掌握，能完成简单任务  
- **Level 3 (5-6分)**：熟练掌握，能独立完成项目
- **Level 4 (7-8分)**：精通，能优化和解决复杂问题
- **Level 5 (9-10分)**：专家级，能指导他人和制定标准

### 答题方式
每个技能模块包含不同难度的题目，按顺序作答，最后统计总分评估水平。

---

## 🔥 JavaScript 基础技能测试

### A. ES6+ 语法测试 (总分10分)

**题目A1 (1分-基础)：以下哪些是ES6新增的特性？**
```
A. let/const 声明
B. 箭头函数  
C. 模板字符串
D. 解构赋值
E. 以上都是
```
**我的答案**：__E___
**标准答案**：E (以上都是)
**解析**：let/const声明、箭头函数、模板字符串、解构赋值都是ES6引入的重要特性
**评分**：选对得1分

**题目A2 (2分-基础)：分析以下代码输出结果**
```javascript
const arr = [1, 2, 3];
const [a, ...rest] = arr;
const newArr = [...rest, a];
console.log(newArr);
```
**我的答案**：__[2, 3, 1]___
**标准答案**：[2, 3, 1]
**解析**：
1. `const [a, ...rest] = arr` - a=1, rest=[2,3]
2. `const newArr = [...rest, a]` - 将rest展开后加上a，得到[2,3,1]
**评分**：答对得2分，错误得0分

**题目A3 (3分-中级)：完善代码实现数组去重**
```javascript
const arr = [1, 2, 2, 3, 4, 4, 5];
// 使用ES6+语法实现去重，写出你的代码
const unique = // 你的代码
```
**我的答案**：
```javascript
const unique = [...new Set(arr)] // 我的代码
```
**标准答案**：
```javascript
// 方法1：使用Set
const unique = [...new Set(arr)];

// 方法2：使用filter + indexOf
const unique = arr.filter((item, index) => arr.indexOf(item) === index);

// 方法3：使用reduce
const unique = arr.reduce((acc, current) => 
  acc.includes(current) ? acc : [...acc, current], []);
```
**解析**：Set自动去除重复值，再用扩展运算符转换为数组是最简洁的方法
**评分**：完全正确3分，思路对但语法错误2分，错误0分

**题目A4 (4分-高级)：解释并优化以下代码**
```javascript
function processData(data) {
  if (data && data.list && data.list.length > 0) {
    return data.list.map(item => {
      if (item.user && item.user.name) {
        return item.user.name.toUpperCase();
      }
      return 'Unknown';
    });
  }
  return [];
}
```
**我的答案**：
```javascript
// 我的优化代码
function processData(data) {
  if (data && Array.isArray(data?.list)) {
    return data.list.map(item => {
        return item.user?.name?.toUpperCase()??'Unknown';
    });
  }
  return [];
}
```
**标准答案**：
```javascript
// 问题：1.多层嵌套判断 2.重复的null检查 3.可读性差
// 优化后：
function processData(data) {
  return data?.list?.map(item => 
    item?.user?.name?.toUpperCase() ?? 'Unknown'
  ) ?? [];
}

// 进一步优化：加入类型检查
function processData(data) {
  if (!data?.list || !Array.isArray(data.list)) {
    return [];
  }
  
  return data.list.map(item => 
    item?.user?.name?.toUpperCase() ?? 'Unknown'
  );
}
```
**解析**：
- 使用可选链操作符(?.) 减少嵌套判断
- 使用空值合并操作符(??) 提供默认值
- 添加Array.isArray检查确保类型安全
**评分**：使用可选链和空值合并4分，部分优化2-3分，不会优化0分

### B. Promise/Async-Await测试 (总分10分)

**题目B1 (2分-基础)：Promise的三种状态是什么？**
**我的答案**：_pending、fulfilled、rejected____
**标准答案**：pending（等待中）、fulfilled（已成功）、rejected（已失败）
**解析**：
- **pending**：初始状态，异步操作尚未完成
- **fulfilled**：异步操作成功完成，有返回值
- **rejected**：异步操作失败，有错误原因
**评分**：全对2分，答对2个1分，少于2个0分

**题目B2 (2分-基础)：以下代码的执行顺序是什么？**
```javascript
console.log('1');
Promise.resolve().then(() => console.log('2'));
console.log('3');
setTimeout(() => console.log('4'), 0);
console.log('5');
```
**我的答案**：_1、3、5、2、4____
**标准答案**：1 → 3 → 5 → 2 → 4
**解析**：
1. `console.log('1')` - 同步代码，立即执行
2. `Promise.resolve().then(...)` - 微任务，加入微任务队列
3. `console.log('3')` - 同步代码，立即执行
4. `setTimeout(...)` - 宏任务，加入宏任务队列
5. `console.log('5')` - 同步代码，立即执行
6. 同步代码执行完成，执行微任务队列中的任务 '2'
7. 微任务清空，执行宏任务队列中的任务 '4'
**评分**：完全正确2分，错误0分

**题目B3 (3分-中级)：修复以下代码的性能问题**
```javascript
async function fetchUserData(userIds) {
  const users = [];
  for (const id of userIds) {
    const user = await fetch(`/api/users/${id}`);
    users.push(await user.json());
  }
  return users;
}
```
**我的答案**：
```javascript
// 我的修复代码
async function fetchUserData(userIds) {
  const promises = userIds.map((id) => fetch(`/api/users/${id}`).then(res => res.json()))
  return Promise.all(promises)
}
```
**标准答案**：
```javascript
// 问题：串行执行，性能低下
// 修复后：并行执行
async function fetchUserData(userIds) {
  const promises = userIds.map(id => 
    fetch(`/api/users/${id}`).then(res => res.json())
  );
  return Promise.all(promises);
}

// 更完善的版本（包含错误处理）
async function fetchUserData(userIds) {
  try {
    const promises = userIds.map(async (id) => {
      const response = await fetch(`/api/users/${id}`);
      if (!response.ok) {
        throw new Error(`Failed to fetch user ${id}`);
      }
      return response.json();
    });
    return await Promise.all(promises);
  } catch (error) {
    console.error('Error fetching users:', error);
    throw error;
  }
}
```
**解析**：
- 原代码问题：使用for...of + await导致串行执行，如果有3个用户，每个请求舁1秒，总时间为3秒
- 解决方案：使用map创建Promise数组，再Promise.all并行执行，总时间约1秒
**评分**：使用Promise.all并行3分，知道问题但实现有误2分，不知道问题0分

**题目B4 (3分-高级)：实现一个带重试机制的异步函数**
```javascript
// 实现 retryAsync(fn, maxRetries, delay)
// fn: 要执行的异步函数
// maxRetries: 最大重试次数  
// delay: 重试间隔时间(ms)
async function retryAsync(fn, maxRetries, delay) {
  // 你的实现
}
```
**我的答案**：
```javascript
// 我的实现
async function retryAsync(fn, maxRetries, delay) {
  // 你的实现
  for (let i = 0; i <= maxRetries; i++) {
    try {
        const result = await fn();
        return result;
    } catch (error) { 
        if (i === maxRetries) {
            throw new Error(`重试失败，错误信息：${error}`);
        } else {
            await new Promise((resolve) => setTimeout(resolve, delay));
        }
    }
  }
}
```
**标准答案**：
```javascript
async function retryAsync(fn, maxRetries, delay) {
  let lastError;
  
  for (let i = 0; i <= maxRetries; i++) {
    try {
      const result = await fn();
      return result; // 成功则直接返回
    } catch (error) {
      lastError = error;
      
      // 如果还有重试机会，则等待后重试
      if (i < maxRetries) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  // 所有重试都失败，抛出最后一次的错误
  throw new Error(`重试${maxRetries}次后仍然失败: ${lastError.message}`);
}

// 使用示例：
const fetchData = () => fetch('/api/data').then(res => {
  if (!res.ok) throw new Error('Network error');
  return res.json();
});

// 最多重试3次，每次间隔1秒
retryAsync(fetchData, 3, 1000)
  .then(data => console.log('数据获取成功:', data))
  .catch(err => console.error('最终失败:', err));
```
**解析**：
- 使用for循环控制重试次数（注意是`i <= maxRetries`，因为包含第一次尝试）
- 使用try-catch捕获异步函数的错误
- 成功时立即返回结果，失败时先等待再重试
- 所有重试都失败后抛出最后一次的错误
**评分**：完整实现3分，基本思路对但有小错误2分，思路错误0-1分

### C. 闭包和作用域测试 (总分10分)

**题目C1 (2分-基础)：解释什么是闭包？**
**我的答案**：__一个函数运行的结果是返回一个函数，并且该函数可以调用函数外部的变量___
**标准答案**：闭包是指在一个函数内部定义的函数，并且这个内部函数可以访问其外部函数的变量和参数，即使在外部函数返回后，这些变量仍然可以被内部函数访问。
**解析**：
- 闭包的核心是**作用域链**和**变量保持**
- 内部函数可以“记住”外部函数的变量，形成数据封装
- 常用于模块化、数据隐藏、回调函数等场景
**评分**：概念清晰2分，理解但表达不准确1分，错误0分

**题目C2 (3分-中级)：分析以下代码输出**
```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}

for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 100);
}
```
**我的答案**：__2、0、1、2___
**标准答案**：
- 第一个循环输出：3 3 3
- 第二个循环输出：0 1 2
**解析**：
- **var i**：函数作用域，所有setTimeout共享同一个i，循环结束时i=3，所以输出3个3
- **let j**：块级作用域，每次循环都会创建新的j，形成闭包，保持各自的值
```javascript
// 等效于var的闭包解决方案：
for (var i = 0; i < 3; i++) {
  (function(index) {
    setTimeout(() => console.log(index), 100);
  })(i);
}
```
**评分**：完全正确3分，只答对一半1-2分，错误0分

**题目C3 (5分-高级)：实现一个模块化的计数器**
```javascript
// 实现一个计数器工厂，要求：
// 1. 每个计数器独立
// 2. 提供 increment, decrement, getValue 方法
// 3. 外部无法直接访问计数值
function createCounter(initialValue = 0) {
  // 你的实现
}
```
**我的答案**：
```javascript
// 我的实现
function createCounter(initialValue = 0) {
  // 你的实现
  let count = initialValue;
  function increment() {
    count++
  }
  function decrement() {
    count--
  }
  function getValue() {
    return count
  }
  return {
    increment,
    decrement,
    getValue
  }
}
```
**标准答案**：
```javascript
function createCounter(initialValue = 0) {
  let count = initialValue; // 私有变量，外部无法直接访问
  
  return {
    increment() {
      return ++count; // 返回新值
    },
    decrement() {
      return --count; // 返回新值
    },
    getValue() {
      return count; // 只读访问
    }
  };
}

// 使用示例：
const counter1 = createCounter(10);
const counter2 = createCounter(0);

console.log(counter1.increment()); // 11
console.log(counter1.getValue());  // 11
console.log(counter2.increment()); // 1 - 独立的计数器
console.log(counter1.getValue());  // 11 - 不受影响
```
**解析**：
- 使用闭包封装count变量，实现数据隐藏
- 每次调用createCounter都会创建新的作用域，保证计数器独立
- 返回的方法可以访问外部作用域的count变量
**评分**：完整实现5分，基本思路对但有缺陷3-4分，不理解闭包0-2分

### D. 原型链和继承测试 (总分10分)

**题目D1 (2分-基础)：JavaScript中实现继承的方式有哪些？**
**我的答案**：_extends关键字、call、prototype、clone、apply、create____
**标准答案**：
1. **原型链继承** - 子类原型指向父类实例
2. **构造函数继承** - 在子类中调用父类构造函数（call/apply）
3. **组合继承** - 结合原型链和构造函数继承
4. **原型式继承** - Object.create()
5. **寄生式继承** - 在原型式继承基础上增强对象
6. **寄生组合式继承** - 最理想的继承方式
7. **ES6 class继承** - extends关键字
**解析**：你提到的部分正确，extends、call、apply、Object.create都是实现继承的方式
**评分**：说出4种以上2分，说出2-3种1分，少于2种0分

**题目D2 (3分-中级)：分析以下代码的原型关系**
```javascript
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function() {
  console.log(`Hello, I'm ${this.name}`);
};

function Student(name, grade) {
  Person.call(this, name);
  this.grade = grade;
}
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

const student = new Student('Tom', 5);
```
请画出原型链关系图或文字描述。
**我的答案**：__Student的原型指向Person___
**标准答案**：
```
原型链关系图：
student → Student.prototype → Person.prototype → Object.prototype → null

详细关系：
1. student.__proto__ === Student.prototype
2. Student.prototype.__proto__ === Person.prototype  
3. Person.prototype.__proto__ === Object.prototype
4. Object.prototype.__proto__ === null

构造函数关系：
- student.constructor === Student
- Student.prototype.constructor === Student
- Person.prototype.constructor === Person
```
**解析**：
- `Object.create(Person.prototype)` 创建了一个原型指向Person.prototype的新对象
- `Student.prototype.constructor = Student` 修复了constructor指向
- 这样实现了Student继承Person的原型方法
**评分**：准确描述原型链3分，基本理解但不够准确2分，错误理解0-1分

**题目D3 (5分-高级)：用ES6 class重写上述继承关系，并添加getter/setter**
**我的答案**：
```javascript
// 我的ES6 class实现
class Person {
    constructor(name) {
        this.name = name
    }
    sayHello() {
        console.log(`Hello, I'm ${this.name}`);
    }
    getter:{

    }
    setter:{

    }
}

class Student extends Person {
    constructor(name, grade){
        super(name)
        this.grade = grade;
    }
}
```
**标准答案**：
```javascript
class Person {
  constructor(name) {
    this._name = name;
  }
  
  // getter
  get name() {
    return this._name;
  }
  
  // setter  
  set name(value) {
    if (typeof value === 'string' && value.length > 0) {
      this._name = value;
    } else {
      throw new Error('名字必须是非空字符串');
    }
  }
  
  sayHello() {
    console.log(`Hello, I'm ${this.name}`);
  }
}

class Student extends Person {
  constructor(name, grade) {
    super(name); // 调用父类构造函数
    this._grade = grade;
  }
  
  // getter
  get grade() {
    return this._grade;
  }
  
  // setter加入数据验证
  set grade(value) {
    if (Number.isInteger(value) && value >= 1 && value <= 12) {
      this._grade = value;
    } else {
      throw new Error('年级必须是1-12之间的整数');
    }
  }
  
  // 重写父类方法
  sayHello() {
    console.log(`Hello, I'm ${this.name}, Grade ${this.grade}`);
  }
  
  // 子类特有方法
  study() {
    console.log(`${this.name} is studying...`);
  }
}

// 使用示例：
const student = new Student('Tom', 5);
student.sayHello(); // "Hello, I'm Tom, Grade 5"
student.grade = 6;  // setter验证
console.log(student.grade); // 6 - getter访问
```
**解析**：
- ES6 class语法更简洁清晰，但本质仍是原型继承
- getter/setter提供了属性访问的控制和验证
- super()必须在constructor中第一行调用
**评分**：完整实现5分，基本语法对但缺少细节3-4分，语法错误0-2分

### E. 事件循环机制测试 (总分10分)

**题目E1 (3分-基础)：解释JavaScript事件循环的基本概念**
**我的答案**：_同步代码->宏任务->微任务____
**标准答案**：JavaScript是单线程的，通过**事件循环(Event Loop)**机制处理异步任务。事件循环包括：
- **调用栈(Call Stack)** - 执行同步代码
- **任务队列(宏任务队列)** - setTimeout、setInterval等
- **微任务队列(Microtask Queue)** - Promise.then、queueMicrotask等

**执行顺序**：同步代码 → 清空所有微任务 → 执行一个宏任务 → 再清空微任务...
**解析**：你的理解顺序有误，正确的是：每次宏任务执行后，都会清空所有微任务
**评分**：概念准确完整3分，理解但不够准确2分，错误理解0-1分

**题目E2 (4分-中级)：分析复杂异步代码执行顺序**
```javascript
console.log('start');

setTimeout(() => console.log('timeout1'), 0);

Promise.resolve().then(() => {
  console.log('promise1');
  setTimeout(() => console.log('timeout2'), 0);
});

Promise.resolve().then(() => console.log('promise2'));

console.log('end');
```
**我的答案**：_start、end、timeout1、promise1、promise2、timeout2____
**标准答案**：start → end → promise1 → promise2 → timeout1 → timeout2
**解析**：
1. `console.log('start')` - 同步代码，立即执行
2. `setTimeout(() => console.log('timeout1'), 0)` - 宏任务，加入宏任务队列
3. `Promise.resolve().then(...)` - 微任务，加入微任务队列
4. `Promise.resolve().then(() => console.log('promise2'))` - 微任务，加入微任务队列
5. `console.log('end')` - 同步代码，立即执行
6. 同步代码执行完成，清空微任务队列：
   - 执行promise1回调，在其中又添加一个setTimeout(宏任务)
   - 执行promise2回调
7. 微任务清空后，执行宏任务队列：timeout1、timeout2
**评分**：完全正确4分，小错误2-3分，大错误0-1分

**题目E3 (3分-高级)：解释微任务和宏任务的区别，并举例**
**我的答案**：_____
**标准答案**：
- **微任务**：Promise.then/catch/finally、queueMicrotask、MutationObserver等
- **宏任务**：setTimeout、setInterval、setImmediate、I/O操作等  
- **区别**：每次事件循环，先执行完所有微任务，再执行一个宏任务
**评分**：概念和例子都准确3分，概念对但例子不够2分，错误0-1分

---

## 🎨 CSS 进阶技能测试

### F. Flexbox 高级应用测试 (总分10分)

**题目F1 (2分-基础)：Flexbox的主要属性分别作用于什么？**
**我的答案**：_____
**标准答案**：
- **容器属性**：display、flex-direction、flex-wrap、justify-content、align-items、align-content
- **项目属性**：flex-grow、flex-shrink、flex-basis、align-self、order
**评分**：分类正确且说出主要属性2分，部分正确1分，错误0分

**题目F2 (3分-中级)：实现水平垂直居中的多种方案**
```css
/* 使用Flexbox实现以下布局要求：
   1. 容器内元素水平垂直居中
   2. 如果内容过多，允许滚动
   3. 保持元素最小宽度300px */
.container {
  /* 你的CSS */
  display: flex;
  justify-content: center;
  items-content: center;
  wrap: no-wrap;
  overflow-x: scroll;
}
.content {
  /* 你的CSS */
  min-width: 300px;
}
```
**我的答案**：
```css
/* 我的CSS实现 */
.container {
  /* 我的CSS */
  display: flex;
  justify-content: center;
  align-items: center;
  overflow-x: scroll;
}
.content {
  /* 我的CSS */
  min-width: 300px;
}
```
**标准答案**：
```css
.container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  overflow: auto; /* 允许滚动 */
  padding: 20px; /* 防止内容贴边 */
}
.content {
  min-width: 300px;
  max-width: 90%; /* 防止在小屏幕上超出 */
  width: 100%;
  box-sizing: border-box;
}

/* 更完善的版本 */
.container {
  display: flex;
  justify-content: center;
  align-items: flex-start; /* 防止内容超出时居中问题 */
  min-height: 100vh;
  overflow-y: auto;
  padding: 20px;
}
.content {
  min-width: 300px;
  max-width: 800px;
  width: 100%;
  margin: auto; /* 在flex中实现居中 */
}
```
**解析**：
- 你的`items-content`应该是`align-items`
- `wrap: no-wrap`应该是`flex-wrap: nowrap`
- `overflow-x`应该是`overflow`或`overflow-y`
**评分**：完整实现3分，基本实现但缺少细节2分，错误思路0-1分

**题目F3 (5分-高级)：复杂Flexbox布局挑战**
```
设计一个响应式卡片布局：
- 桌面端：每行3个卡片，等宽
- 平板端：每行2个卡片  
- 移动端：每行1个卡片
- 卡片之间有间距，容器有内边距
- 最后一行卡片靠左对齐
```
**我的答案**：
```css
/* 我的CSS实现 */
.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(33%, 1fr));
  gap: 20px 15px;
}
```
**标准答案**：
```css
.card-container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  padding: 20px;
  justify-content: flex-start; /* 最后一行靠左对齐 */
}

.card {
  flex: 0 0 calc(33.333% - 14px); /* 3个一行，减去gap的影响 */
  min-width: 250px;
  background: #f5f5f5;
  border-radius: 8px;
  padding: 16px;
  box-sizing: border-box;
}

/* 响应式设计 */
@media (max-width: 1024px) {
  .card {
    flex: 0 0 calc(50% - 10px); /* 2个一行 */
  }
}

@media (max-width: 768px) {
  .card {
    flex: 0 0 100%; /* 1个一行 */
  }
  
  .card-container {
    padding: 16px;
    gap: 16px;
  }
}

/* 更精确的版本（使用Container Queries）*/
.card-container {
  display: flex;
  flex-wrap: wrap;
  gap: 20px;
  padding: 20px;
}

.card {
  flex: 1 1 300px; /* 自适应，最小300px */
  max-width: calc(33.333% - 14px);
  min-width: 250px;
}
```
**解析**：你使用了Grid而不是Flexbox。Flexbox的关键是`flex-wrap`和`flex`属性的组合使用
**评分**：完整实现5分，基本思路对但细节有误3-4分，不会响应式设计0-2分

### G. Grid 布局系统测试 (总分10分)

**题目G1 (3分-基础)：Grid布局的基本概念和属性**
**我的答案**：_____
**标准答案**：Grid布局是**二维布局系统**，可以同时控制行和列。主要属性包括：

**容器属性：**
- `display: grid` - 定义网格容器
- `grid-template-columns/rows` - 定义列/行的大小
- `grid-template-areas` - 定义网格区域
- `gap/grid-gap` - 设置间距
- `grid-auto-flow` - 控制自动放置方向

**项目属性：**
- `grid-column/grid-row` - 指定项目占据的列/行
- `grid-area` - 指定项目占据的区域
- `justify-self/align-self` - 单个项目的对齐方式
**评分**：概念清晰且说出主要属性3分，基本理解2分，错误0-1分

**题目G2 (4分-中级)：实现经典网页布局**
```css
/* 实现以下布局：
   header (全宽)
   sidebar | main content | sidebar
   footer (全宽)
   要求：侧边栏固定宽度200px，主内容自适应 */
.layout {
  /* 你的CSS */
}
```
**我的答案**：
.header,.footer {
    width: 100%;
}
.sidebar {
    width: 220px;
}
```css
/* 我的CSS实现 */
```
**标准答案**：
```css
.layout {
  display: grid;
  grid-template-areas: 
    "header header header"
    "sidebar1 main sidebar2"
    "footer footer footer";
  grid-template-columns: 200px 1fr 200px;
  grid-template-rows: auto 1fr auto;
  min-height: 100vh;
  gap: 10px; /* 可选的间距 */
}

/* 各个区域的指定 */
.header { 
  grid-area: header;
  background: #f1f1f1;
}
.sidebar1 { 
  grid-area: sidebar1;
  background: #e1e1e1;
}
.main { 
  grid-area: main;
  background: #fff;
  overflow-y: auto; /* 内容过多时滚动 */
}
.sidebar2 { 
  grid-area: sidebar2;
  background: #e1e1e1;
}
.footer { 
  grid-area: footer;
  background: #f1f1f1;
}

/* 响应式版本 */
@media (max-width: 768px) {
  .layout {
    grid-template-areas: 
      "header"
      "main"
      "sidebar1"
      "sidebar2"
      "footer";
    grid-template-columns: 1fr;
    grid-template-rows: auto 1fr auto auto auto;
  }
}
```
**解析**：
- `grid-template-areas`提供了直观的布局定义
- `1fr`表示占据剩余空间
- 响应式设计在小屏幕上改为单列布局
**评分**：完整实现4分，基本实现但有小错误3分，错误思路0-2分

**题目G3 (3分-高级)：响应式Grid布局**
```
创建一个自适应的产品网格：
- 容器宽度改变时，自动调整列数
- 最小列宽250px，最大1fr
- 行间距20px，列间距15px
```
**标准答案**：
```css
.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px 15px;
}
```
**评分**：使用auto-fit和minmax完整实现3分，基本思路对2分，错误0-1分

---

## 📋 TypeScript 技能测试

### H. 基本类型系统测试 (总分10分)

**题目H1 (2分-基础)：TypeScript的基本类型有哪些？**
**我的答案**：_string、number、boolean、object、array、symbol、bigint、null、undefined____
**评分**：说出8个以上2分，说出5-7个1分，少于5个0分

**题目H2 (3分-中级)：定义复杂数据结构的类型**
```typescript
// 为以下用户数据定义完整的TypeScript类型
const userData = {
  id: 1,
  name: "张三",
  email: "zhangsan@example.com",
  profile: {
    age: 25,
    avatar: "https://example.com/avatar.jpg",
    interests: ["编程", "音乐", "旅行"]
  },
  posts: [
    { id: 1, title: "我的第一篇文章", publishDate: "2024-01-01" },
    { id: 2, title: "TypeScript学习笔记", publishDate: "2024-01-15" }
  ]
};
```
**我的答案**：
```typescript
// 我的类型定义
interface Profile {
    age: number;
    avatar: string;
    interests: string[];
}
interface Posts {
    id: number;
    title: string;
    publishDate: string;
}
interface User {
    id: number;
    name: string;
    email: string;
    profile: Profile;
    posts:  Posts[]
}
```
**标准答案**：
```typescript
// 定义子接口
interface Post {
  id: number;
  title: string;
  publishDate: string; // 或者使用 Date 类型
}

interface Profile {
  age: number;
  avatar: string;
  interests: string[]; // 或者使用 Array<string>
}

// 主接口
interface User {
  id: number;
  name: string;
  email: string;
  profile: Profile;
  posts: Post[]; // 或者使用 Array<Post>
}

// 使用示例
const userData: User = {
  id: 1,
  name: "张三",
  email: "zhangsan@example.com",
  profile: {
    age: 25,
    avatar: "https://example.com/avatar.jpg",
    interests: ["编程", "音乐", "旅行"]
  },
  posts: [
    { id: 1, title: "我的第一篇文章", publishDate: "2024-01-01" },
    { id: 2, title: "TypeScript学习笔记", publishDate: "2024-01-15" }
  ]
};

// 更严格的版本（包含可选属性和联合类型）
interface StrictUser {
  readonly id: number; // 只读属性
  name: string;
  email: string;
  profile: Profile;
  posts: Post[];
  createdAt?: Date; // 可选属性
  status: 'active' | 'inactive' | 'banned'; // 字面量类型
}
```
**解析**：你的实现基本正确，但`profile: profile`应该是`profile: Profile`（大写P）
**评分**：完整定义3分，基本正确但有小错误2分，不会定义接口0-1分

**题目H3 (5分-高级)：泛型和高级类型**
```typescript
// 实现一个通用的API响应类型和数据获取函数
// 要求：支持不同的数据类型，包含状态码、消息、数据等字段
type ApiResponse<T> = // 你的类型定义

function fetchData<T>(url: string): Promise<ApiResponse<T>> {
  // 你的实现
}

// 使用示例
const userResponse = await fetchData<User>('/api/users/1');
```
**我的答案**：
```typescript
// 我的泛型实现
type ApiResponse<T> = {
    statusCode: number;
    message: string;
    data: T;
}
function fetchData<T>(url: string): Promise<ApiResponse<T>> {
  // 你的实现
  return new Promise((resolve, reject) => {
    fetch(url).then(res => res.json())
  })
}
```
**标准答案**：
```typescript
// 定义通用的API响应类型
type ApiResponse<T> = {
  success: boolean;
  statusCode: number;
  message: string;
  data: T | null;
  timestamp: number;
  errors?: string[]; // 可选的错误信息
};

// 更严格的版本，使用判别联合
type ApiSuccessResponse<T> = {
  success: true;
  statusCode: 200 | 201;
  message: string;
  data: T;
  timestamp: number;
};

type ApiErrorResponse = {
  success: false;
  statusCode: 400 | 401 | 403 | 404 | 500;
  message: string;
  data: null;
  timestamp: number;
  errors?: string[];
};

type StrictApiResponse<T> = ApiSuccessResponse<T> | ApiErrorResponse;

// 数据获取函数实现
async function fetchData<T>(url: string): Promise<ApiResponse<T>> {
  try {
    const response = await fetch(url);
    const data = await response.json();
    
    return {
      success: response.ok,
      statusCode: response.status,
      message: response.ok ? 'Success' : 'Request failed',
      data: response.ok ? data : null,
      timestamp: Date.now(),
      ...(response.ok ? {} : { errors: [response.statusText] })
    };
  } catch (error) {
    return {
      success: false,
      statusCode: 500,
      message: 'Network error',
      data: null,
      timestamp: Date.now(),
      errors: [error instanceof Error ? error.message : 'Unknown error']
    };
  }
}

// 使用示例：
interface User {
  id: number;
  name: string;
  email: string;
}

// 使用方式1：基本使用
const userResponse = await fetchData<User>('/api/users/1');
if (userResponse.success && userResponse.data) {
  console.log(userResponse.data.name); // 类型安全
}

// 使用方式2：结合类型守卫
function isSuccessResponse<T>(response: ApiResponse<T>): response is ApiSuccessResponse<T> {
  return response.success === true;
}

if (isSuccessResponse(userResponse)) {
  // 这里 TypeScript 知道 data 不会是 null
  console.log(userResponse.data.name);
}
```
**解析**：你的实现有以下问题：
1. Promise实现不完整，没有resolve
2. 缺少错误处理
3. 没有返回值
**评分**：完整实现泛型和错误处理5分，基本泛型使用3-4分，不会泛型0-2分

---

## 📊 评估系统

### 自动评分计算器

| 技能模块 | 你的得分 | 满分 | 得分率 |
|---------|---------|------|---------|
| ES6+ 语法 | **9**/10 | 10 | **90%** |
| Promise/Async-Await | **8**/10 | 10 | **80%** |
| 闭包和作用域 | **5**/10 | 10 | **50%** |
| 原型链和继承 | **4**/10 | 10 | **40%** |
| 事件循环机制 | **2**/10 | 10 | **20%** |
| Flexbox应用 | **2**/10 | 10 | **20%** |
| Grid布局 | **4**/10 | 10 | **40%** |
| TypeScript基础 | **7**/10 | 10 | **70%** |
| **总计** | **41/80** | **80** | **51.25%** |

| 技能模块 | 你的得分 | 满分 | 得分率 |
|---------|---------|------|--------|
| ES6+ 语法 | ___/10 | 10 | ___% |
| Promise/Async-Await | ___/10 | 10 | ___% |
| 闭包和作用域 | ___/10 | 10 | ___% |
| 原型链和继承 | ___/10 | 10 | ___% |
| 事件循环机制 | ___/10 | 10 | ___% |
| Flexbox应用 | ___/10 | 10 | ___% |
| Grid布局 | ___/10 | 10 | ___% |
| TypeScript基础 | ___/10 | 10 | ___% |
| **总计** | **___/80** | **80** | **___%** |

### 水平等级评估

#### JavaScript 基础能力评估
- **ES6+ 语法得分** **9**/10 → Level **5**
- **Promise/Async得分** **8**/10 → Level **4**  
- **闭包作用域得分** **5**/10 → Level **3**
- **原型链继承得分** **4**/10 → Level **2**
- **事件循环得分** **2**/10 → Level **1**

**JavaScript综合水平**：Level **3**

#### CSS 进阶能力评估  
- **Flexbox得分** **2**/10 → Level **1**
- **Grid布局得分** **4**/10 → Level **2**

**CSS综合水平**：Level **1.5**

#### TypeScript 能力评估
- **类型系统得分** **7**/10 → Level **4**

**TypeScript水平**：Level **4**

### 等级换算表
- **0-2分** → Level 1 (基础了解)
- **3-4分** → Level 2 (基本掌握)  
- **5-6分** → Level 3 (熟练掌握)
- **7-8分** → Level 4 (精通)
- **9-10分** → Level 5 (专家级)

### 综合评估报告

#### 你的技能雷达图
请根据各模块得分，画出你的技能雷达图：

```
技能维度评分：
- ES6+语法: **4.5**/5
- Promise/Async: **4**/5  
- 闭包作用域: **2.5**/5
- 原型链继承: **2**/5
- 事件循环: **1**/5
- Flexbox: **1**/5
- Grid布局: **2**/5
- TypeScript: **3.5**/5
```

#### 学习建议

**强项技能** (Level 4-5)：
- [x] **ES6+语法** - 控制得非常好，继续保持
- [x] **Promise/Async** - 基础牢固，可在复杂场景下练习
- [x] **TypeScript** - 类型系统掌握较好

**需要提升** (Level 1-3)：
- [ ] **事件循环机制** (建议学习资源：《深入理解JavaScript》、事件循环视频教程)
- [ ] **Flexbox布局** (建议学习资源：CSS Tricks、Flexbox Froggy游戏)
- [ ] **原型链和继承** (建议学习资源：《JavaScript高级程序设计》)
- [ ] **闭包和作用域** (建议学习资源：《你不知道的JavaScript》)
- [ ] **Grid布局** (建议学习资源：Grid Garden游戏、MDN文档)

**学习优先级排序**：
1. 高优先级：**事件循环机制** - 基础概念，影响整体JS理解
2. 中优先级：**Flexbox布局** - 实用技能，日常开发必备  
3. 低优先级：**原型链继承** - 进阶概念，可后期深入

#### 下阶段学习计划

**本月重点**：**JavaScript事件循环机制** + **Flexbox布局**
**学习资源**：《深入理解JavaScript》 + CSS-Tricks Flexbox教程
**实践项目**：事件循环演示项目 + 响应式布局练习
**预期提升**：事件循环Level 1 → Level 3，Flexbox Level 1 → Level 3

---

## 📊 详细评估报告

### 📈 整体水平分析

**总分：41/80 (51.25%) - Level 3 (熟练掌握)**

你在前端技能上属于**中级水平**，具备较好的ES6+语法和Promise基础，可以独立完成中等复杂度的项目。

### ⭐ 优势领域
1. **ES6+语法** (90%) - 接近专家水平
2. **Promise/Async** (80%) - 精通水平
3. **TypeScript** (70%) - 精通水平

### ⚠️ 待改进领域
1. **事件循环机制** (20%) - 急需加强
2. **Flexbox布局** (20%) - 急需加强  
3. **原型链继承** (40%) - 需要提升

### 🎯 具体问题分析

1. **事件循环理解不够深入**：
   - E2题对执行顺序理解错误
   - 微任务和宏任务概念模糊

2. **CSS布局技能薄弱**：
   - Flexbox属性记忆不准确
   - Grid布局的基本概念理解不清

3. **原型链细节掌握不够**：
   - 继承方式的具体实现不清楚
   - ES6 class语法错误

---

## 🎯 使用说明

1. **完整作答**：按顺序完成所有题目，诚实填写答案
2. **自我评分**：根据标准答案给自己评分
3. **计算等级**：使用等级换算表确定各技能水平
4. **制定计划**：根据评估结果制定学习计划
5. **定期测试**：建议每月重新测试，跟踪进步

**注意**：这个测试重在了解真实水平，诚实作答比高分更重要！